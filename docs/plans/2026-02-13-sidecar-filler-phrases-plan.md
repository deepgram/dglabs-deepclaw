# Sidecar Filler Phrases Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Inject filler phrases during slow OpenClaw think responses so voice callers don't hear dead air.

**Architecture:** Proxy-based injection. The `/v1/chat/completions` proxy detects slow responses and sends `InjectAgentMessage` to the Deepgram WebSocket via a session registry. Dynamic phrases generated by Claude Haiku; static phrases as fallback.

**Tech Stack:** Python 3.12, FastAPI, httpx, websockets, pytest-asyncio, pydantic-settings

**Design doc:** `docs/plans/2026-02-13-sidecar-filler-phrases-design.md`

**All file paths relative to:** `Deepgram/deepgram_handler/`

**Run tests with:** `cd Deepgram/deepgram_handler && uv run pytest tests/ -v`

---

### Task 1: Add Filler Configuration to Settings

**Files:**

- Modify: `app/config.py`
- Modify: `tests/conftest.py`

**Step 1: Add new settings fields to `app/config.py`**

Add these fields to the `Settings` class, after the existing `TWILIO_PROXY_URL` field:

```python
    # Filler phrases (for voice call dead-air prevention)
    FILLER_THRESHOLD_MS: int = 1500
    FILLER_PHRASES: str = ""
    FILLER_DYNAMIC: bool = True
    ANTHROPIC_API_KEY: str = ""
```

Add a `filler_phrases_list` property to the `Settings` class (pydantic v2 requires `@property` — no `@computed_field` needed since we only use it internally):

```python
    @property
    def filler_phrases_list(self) -> list[str]:
        if not self.FILLER_PHRASES:
            return []
        return [p.strip() for p in self.FILLER_PHRASES.split(",") if p.strip()]
```

**Step 2: Add default env vars to `tests/conftest.py`**

Add after the existing `TWILIO_PROXY_URL` line:

```python
os.environ.setdefault("ANTHROPIC_API_KEY", "test-anthropic-key")
```

**Step 3: Run existing tests to verify nothing breaks**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/ -v`
Expected: All existing tests PASS. The new fields have defaults so existing `Settings()` calls still work.

**Step 4: Commit**

```bash
git add Deepgram/deepgram_handler/app/config.py Deepgram/deepgram_handler/tests/conftest.py
git commit -m "feat(sidecar): add filler phrase configuration settings"
```

---

### Task 2: Session Registry

**Files:**

- Create: `app/services/session_registry.py`
- Create: `tests/test_session_registry.py`

**Step 1: Write the failing tests**

Create `tests/test_session_registry.py`:

```python
from unittest.mock import MagicMock

from app.services.session_registry import get_ws, register, unregister


def test_register_and_get_ws():
    mock_ws = MagicMock()
    register("agent:main:abc123", mock_ws)
    assert get_ws("agent:main:abc123") is mock_ws
    # Cleanup
    unregister("agent:main:abc123")


def test_get_ws_returns_none_for_unknown():
    assert get_ws("agent:main:nonexistent") is None


def test_unregister_removes_session():
    mock_ws = MagicMock()
    register("agent:main:xyz789", mock_ws)
    unregister("agent:main:xyz789")
    assert get_ws("agent:main:xyz789") is None


def test_unregister_noop_for_unknown():
    # Should not raise
    unregister("agent:main:never-registered")


def test_register_overwrites_existing():
    ws1 = MagicMock()
    ws2 = MagicMock()
    register("agent:main:same-key", ws1)
    register("agent:main:same-key", ws2)
    assert get_ws("agent:main:same-key") is ws2
    # Cleanup
    unregister("agent:main:same-key")
```

**Step 2: Run tests to verify they fail**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_session_registry.py -v`
Expected: FAIL — `ModuleNotFoundError: No module named 'app.services.session_registry'`

**Step 3: Write the implementation**

Create `app/services/session_registry.py`:

```python
"""Session registry mapping OpenClaw session keys to Deepgram WebSocket connections.

Allows the /v1/chat/completions proxy to inject filler phrases into
active Deepgram Voice Agent sessions when think responses are slow.
"""

from __future__ import annotations

from typing import Any

_active_sessions: dict[str, Any] = {}


def register(session_key: str, dg_ws: Any) -> None:
    """Register a Deepgram WebSocket for a session key."""
    _active_sessions[session_key] = dg_ws


def unregister(session_key: str) -> None:
    """Remove a session key from the registry."""
    _active_sessions.pop(session_key, None)


def get_ws(session_key: str) -> Any | None:
    """Look up the Deepgram WebSocket for a session key."""
    return _active_sessions.get(session_key)
```

**Step 4: Run tests to verify they pass**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_session_registry.py -v`
Expected: All 5 tests PASS

**Step 5: Commit**

```bash
git add Deepgram/deepgram_handler/app/services/session_registry.py Deepgram/deepgram_handler/tests/test_session_registry.py
git commit -m "feat(sidecar): add session registry for filler phrase injection"
```

---

### Task 3: Filler Module (Haiku Dynamic Generation)

**Files:**

- Create: `app/services/filler.py`
- Create: `tests/test_filler_generation.py`

**Step 1: Write the failing tests**

Create `tests/test_filler_generation.py`:

```python
import asyncio
from unittest.mock import AsyncMock, patch

import httpx
import pytest

from app.services.filler import generate_filler_phrase


@pytest.mark.asyncio
async def test_generate_filler_phrase_success():
    """Returns a phrase on successful Haiku response."""
    mock_response = httpx.Response(
        200,
        json={
            "content": [{"type": "text", "text": "Let me look into that."}],
        },
        request=httpx.Request("POST", "https://api.anthropic.com/v1/messages"),
    )
    mock_client = AsyncMock()
    mock_client.__aenter__ = AsyncMock(return_value=mock_client)
    mock_client.__aexit__ = AsyncMock(return_value=False)
    mock_client.post = AsyncMock(return_value=mock_response)

    with patch("app.services.filler.httpx.AsyncClient", return_value=mock_client):
        result = await generate_filler_phrase("What's the weather like?", "test-key")

    assert result == "Let me look into that."

    # Verify API call details
    call_kwargs = mock_client.post.call_args[1]
    assert call_kwargs["headers"]["x-api-key"] == "test-key"
    assert call_kwargs["headers"]["anthropic-version"] == "2023-06-01"
    body = call_kwargs["json"]
    assert body["model"] == "claude-haiku-4-5-20251001"
    assert body["max_tokens"] == 50
    assert "weather" in body["messages"][0]["content"]


@pytest.mark.asyncio
async def test_generate_filler_phrase_includes_user_message_in_prompt():
    """The prompt references the user's actual message."""
    mock_response = httpx.Response(
        200,
        json={"content": [{"type": "text", "text": "Checking on that."}]},
        request=httpx.Request("POST", "https://api.anthropic.com/v1/messages"),
    )
    mock_client = AsyncMock()
    mock_client.__aenter__ = AsyncMock(return_value=mock_client)
    mock_client.__aexit__ = AsyncMock(return_value=False)
    mock_client.post = AsyncMock(return_value=mock_response)

    with patch("app.services.filler.httpx.AsyncClient", return_value=mock_client):
        await generate_filler_phrase("Schedule a meeting for Tuesday", "test-key")

    prompt = mock_client.post.call_args[1]["json"]["messages"][0]["content"]
    assert "Schedule a meeting for Tuesday" in prompt


@pytest.mark.asyncio
async def test_generate_filler_phrase_network_error():
    """Returns None on network failure."""
    mock_client = AsyncMock()
    mock_client.__aenter__ = AsyncMock(return_value=mock_client)
    mock_client.__aexit__ = AsyncMock(return_value=False)
    mock_client.post = AsyncMock(side_effect=httpx.ConnectError("connection refused"))

    with patch("app.services.filler.httpx.AsyncClient", return_value=mock_client):
        result = await generate_filler_phrase("Hello", "test-key")

    assert result is None


@pytest.mark.asyncio
async def test_generate_filler_phrase_non_ok_status():
    """Returns None on HTTP error response."""
    mock_response = httpx.Response(
        500,
        json={"error": "internal"},
        request=httpx.Request("POST", "https://api.anthropic.com/v1/messages"),
    )
    mock_client = AsyncMock()
    mock_client.__aenter__ = AsyncMock(return_value=mock_client)
    mock_client.__aexit__ = AsyncMock(return_value=False)
    mock_client.post = AsyncMock(return_value=mock_response)

    with patch("app.services.filler.httpx.AsyncClient", return_value=mock_client):
        result = await generate_filler_phrase("Hello", "test-key")

    assert result is None


@pytest.mark.asyncio
async def test_generate_filler_phrase_empty_api_key():
    """Returns None immediately if API key is empty."""
    result = await generate_filler_phrase("Hello", "")
    assert result is None


@pytest.mark.asyncio
async def test_generate_filler_phrase_empty_content():
    """Returns None if response has no content."""
    mock_response = httpx.Response(
        200,
        json={"content": []},
        request=httpx.Request("POST", "https://api.anthropic.com/v1/messages"),
    )
    mock_client = AsyncMock()
    mock_client.__aenter__ = AsyncMock(return_value=mock_client)
    mock_client.__aexit__ = AsyncMock(return_value=False)
    mock_client.post = AsyncMock(return_value=mock_response)

    with patch("app.services.filler.httpx.AsyncClient", return_value=mock_client):
        result = await generate_filler_phrase("Hello", "test-key")

    assert result is None


@pytest.mark.asyncio
async def test_generate_filler_phrase_timeout():
    """Returns None if Haiku call exceeds hard timeout."""
    async def slow_post(*args, **kwargs):
        await asyncio.sleep(5.0)  # Way past the 2s timeout
        return httpx.Response(200, json={"content": [{"type": "text", "text": "Late."}]})

    mock_client = AsyncMock()
    mock_client.__aenter__ = AsyncMock(return_value=mock_client)
    mock_client.__aexit__ = AsyncMock(return_value=False)
    mock_client.post = slow_post

    with patch("app.services.filler.httpx.AsyncClient", return_value=mock_client):
        result = await generate_filler_phrase("Hello", "test-key")

    assert result is None


@pytest.mark.asyncio
async def test_generate_filler_phrase_strips_whitespace():
    """Strips leading/trailing whitespace from the response."""
    mock_response = httpx.Response(
        200,
        json={"content": [{"type": "text", "text": "  Let me check.  \n"}]},
        request=httpx.Request("POST", "https://api.anthropic.com/v1/messages"),
    )
    mock_client = AsyncMock()
    mock_client.__aenter__ = AsyncMock(return_value=mock_client)
    mock_client.__aexit__ = AsyncMock(return_value=False)
    mock_client.post = AsyncMock(return_value=mock_response)

    with patch("app.services.filler.httpx.AsyncClient", return_value=mock_client):
        result = await generate_filler_phrase("Hello", "test-key")

    assert result == "Let me check."
```

**Step 2: Run tests to verify they fail**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_filler_generation.py -v`
Expected: FAIL — `ModuleNotFoundError: No module named 'app.services.filler'`

**Step 3: Write the implementation**

Create `app/services/filler.py`:

```python
"""Dynamic filler phrase generation via Claude Haiku.

Generates short, context-aware phrases to fill dead air during voice calls
while the LLM or tool calls are processing. Falls back gracefully to None
on any failure (timeout, network error, missing API key).
"""

from __future__ import annotations

import asyncio
import logging

import httpx

logger = logging.getLogger(__name__)

HAIKU_MODEL = "claude-haiku-4-5-20251001"
API_URL = "https://api.anthropic.com/v1/messages"
HARD_TIMEOUT_S = 2.0
MAX_TOKENS = 50


def _build_prompt(user_message: str) -> str:
    return (
        f'You\'re a voice assistant on a phone call. The user just said: "{user_message}". '
        "You need a moment to think. Generate a single short \"thinking\" phrase (under 10 words) "
        "that shows you're considering their specific question -- not a generic acknowledgment.\n"
        'BAD: "Got it." "Sure thing." "Absolutely." (these sound like the real answer starting)\n'
        'GOOD: "Hmm, good question." "Let me think about that." "Oh interesting, one sec."\n'
        "Output ONLY the phrase. End with a period."
    )


async def generate_filler_phrase(user_message: str, api_key: str) -> str | None:
    """Generate a context-aware filler phrase via Claude Haiku.

    Returns the phrase string, or None on any failure.
    """
    if not api_key:
        return None

    try:
        async with asyncio.timeout(HARD_TIMEOUT_S):
            async with httpx.AsyncClient() as client:
                resp = await client.post(
                    API_URL,
                    headers={
                        "Content-Type": "application/json",
                        "x-api-key": api_key,
                        "anthropic-version": "2023-06-01",
                    },
                    json={
                        "model": HAIKU_MODEL,
                        "max_tokens": MAX_TOKENS,
                        "messages": [{"role": "user", "content": _build_prompt(user_message)}],
                    },
                    timeout=HARD_TIMEOUT_S,
                )

                if resp.status_code != 200:
                    logger.warning("Haiku filler returned %d", resp.status_code)
                    return None

                data = resp.json()
                content = data.get("content", [])
                if not content:
                    return None

                text = content[0].get("text", "").strip()
                return text or None

    except (asyncio.TimeoutError, TimeoutError):
        logger.debug("Haiku filler timed out")
        return None
    except Exception:
        logger.debug("Haiku filler failed", exc_info=True)
        return None
```

**Step 4: Run tests to verify they pass**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_filler_generation.py -v`
Expected: All 8 tests PASS

**Step 5: Commit**

```bash
git add Deepgram/deepgram_handler/app/services/filler.py Deepgram/deepgram_handler/tests/test_filler_generation.py
git commit -m "feat(sidecar): add dynamic filler phrase generation via Haiku"
```

---

### Task 4: Bridge Integration (Session Registration)

**Files:**

- Modify: `app/services/deepgram_agent.py`
- Modify: `tests/test_deepgram_agent.py`

**Step 1: Write the failing tests**

Add these tests to the end of `tests/test_deepgram_agent.py`:

```python
@pytest.mark.asyncio
async def test_run_agent_bridge_registers_session(monkeypatch):
    """Bridge registers the session key in the session registry on connect."""
    from app.services import session_registry

    settings = Settings(
        DEEPGRAM_API_KEY="test-key",
        OPENCLAW_GATEWAY_TOKEN="gw-token",
        _env_file=None,
    )

    mock_dg_ws = AsyncMock()
    mock_dg_ws.close = AsyncMock()
    mock_dg_ws.send = AsyncMock()
    async def empty_iter():
        return
        yield
    mock_dg_ws.__aiter__ = lambda self: empty_iter()

    mock_connect = AsyncMock(return_value=mock_dg_ws)
    monkeypatch.setattr("app.services.deepgram_agent.connect", mock_connect)

    mock_generate = AsyncMock()
    monkeypatch.setattr("app.services.deepgram_agent._generate_next_greeting", mock_generate)

    # Track register/unregister calls
    registered_keys: list[str] = []
    unregistered_keys: list[str] = []
    original_register = session_registry.register
    original_unregister = session_registry.unregister

    def track_register(key, ws):
        registered_keys.append(key)
        original_register(key, ws)

    def track_unregister(key):
        unregistered_keys.append(key)
        original_unregister(key)

    monkeypatch.setattr("app.services.deepgram_agent.session_registry.register", track_register)
    monkeypatch.setattr("app.services.deepgram_agent.session_registry.unregister", track_unregister)

    mock_twilio_ws = AsyncMock()
    mock_twilio_ws.receive_text = AsyncMock(side_effect=WebSocketDisconnect())

    await run_agent_bridge(mock_twilio_ws, "stream-reg", settings=settings, call_id="reg-call")

    # Should have registered with the session key
    assert len(registered_keys) == 1
    assert "reg-call" in registered_keys[0]
    assert registered_keys[0] == "agent:main:reg-call"

    # Should have unregistered on cleanup
    assert len(unregistered_keys) == 1
    assert unregistered_keys[0] == registered_keys[0]


@pytest.mark.asyncio
async def test_run_agent_bridge_unregisters_on_error(monkeypatch):
    """Session is unregistered even if the bridge errors out."""
    from app.services import session_registry

    settings = Settings(
        DEEPGRAM_API_KEY="test-key",
        OPENCLAW_GATEWAY_TOKEN="gw-token",
        _env_file=None,
    )

    mock_dg_ws = AsyncMock()
    mock_dg_ws.close = AsyncMock()
    mock_dg_ws.send = AsyncMock()
    # Simulate an error during iteration
    async def error_iter():
        raise RuntimeError("boom")
        yield  # noqa
    mock_dg_ws.__aiter__ = lambda self: error_iter()

    mock_connect = AsyncMock(return_value=mock_dg_ws)
    monkeypatch.setattr("app.services.deepgram_agent.connect", mock_connect)

    mock_generate = AsyncMock()
    monkeypatch.setattr("app.services.deepgram_agent._generate_next_greeting", mock_generate)

    unregistered_keys: list[str] = []
    monkeypatch.setattr(
        "app.services.deepgram_agent.session_registry.unregister",
        lambda key: unregistered_keys.append(key),
    )

    mock_twilio_ws = AsyncMock()
    mock_twilio_ws.receive_text = AsyncMock(side_effect=WebSocketDisconnect())

    await run_agent_bridge(mock_twilio_ws, "stream-err", settings=settings, call_id="err-call")

    assert len(unregistered_keys) == 1
    assert "err-call" in unregistered_keys[0]
```

**Step 2: Run the new tests to verify they fail**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_deepgram_agent.py::test_run_agent_bridge_registers_session tests/test_deepgram_agent.py::test_run_agent_bridge_unregisters_on_error -v`
Expected: FAIL — `session_registry` not imported / `register` not called

**Step 3: Modify `app/services/deepgram_agent.py`**

Add import at the top (after existing imports):

```python
from app.services import session_registry
```

In `run_agent_bridge()`, add registration after `dg_ws.send(json.dumps(config))` and unregistration in the `finally` block. The modified section of `run_agent_bridge` should look like:

```python
    try:
        if call_id is None:
            call_id = uuid.uuid4().hex[:12]

        session_key = f"agent:{settings.OPENCLAW_AGENT_ID}:{call_id}"

        config = build_settings_config(
            settings,
            call_id=call_id,
            prompt_override=prompt_override,
            greeting_override=greeting_override,
        )
        await dg_ws.send(json.dumps(config))
        logger.info("Sent settings config to Deepgram")

        session_registry.register(session_key, dg_ws)

        stop_event = asyncio.Event()

        t2d = asyncio.create_task(_twilio_to_deepgram(twilio_ws, dg_ws, stop_event))
        d2t = asyncio.create_task(
            _deepgram_to_twilio(dg_ws, twilio_ws, stream_sid, stop_event)
        )

        await asyncio.gather(t2d, d2t, return_exceptions=True)

    finally:
        session_registry.unregister(session_key)

        try:
            await dg_ws.close()
        except Exception:
            pass

        # Post-call: generate next greeting (inbound calls only)
        if not prompt_override:
            await _generate_next_greeting(settings, session_key=session_key)
```

Note: The `session_key` variable is now computed before the `try` block's body and used in both registration and the finally block. If `call_id` is None, it's generated first. The `session_key` variable needs to be accessible in the `finally` block, so declare it outside the inner try or restructure slightly. Since `call_id` is set at the top of the try block, and the finally always runs, we need to handle the case where `session_key` might not be defined. The cleanest approach: initialize `session_key = None` before the try, and guard the unregister:

```python
    session_key = None
    try:
        if call_id is None:
            call_id = uuid.uuid4().hex[:12]

        session_key = f"agent:{settings.OPENCLAW_AGENT_ID}:{call_id}"
        ...
        session_registry.register(session_key, dg_ws)
        ...
    finally:
        if session_key:
            session_registry.unregister(session_key)
        ...
```

**Step 4: Run tests to verify they pass**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_deepgram_agent.py -v`
Expected: All tests PASS (existing + 2 new)

**Step 5: Commit**

```bash
git add Deepgram/deepgram_handler/app/services/deepgram_agent.py Deepgram/deepgram_handler/tests/test_deepgram_agent.py
git commit -m "feat(sidecar): register voice sessions for filler phrase injection"
```

---

### Task 5: Proxy Instrumentation (Filler Timer + Injection)

**Files:**

- Modify: `app/routers/openclaw_proxy.py`
- Modify: `tests/test_openclaw_proxy.py`

**Step 1: Write the failing tests**

Add these tests to `tests/test_openclaw_proxy.py`:

```python
from app.routers.openclaw_proxy import _extract_last_user_message


def test_extract_last_user_message_simple():
    body = b'{"messages":[{"role":"user","content":"What is the weather?"}]}'
    assert _extract_last_user_message(body) == "What is the weather?"


def test_extract_last_user_message_multiple():
    body = b'{"messages":[{"role":"user","content":"Hello"},{"role":"assistant","content":"Hi"},{"role":"user","content":"Weather?"}]}'
    assert _extract_last_user_message(body) == "Weather?"


def test_extract_last_user_message_no_user():
    body = b'{"messages":[{"role":"system","content":"You are helpful"}]}'
    assert _extract_last_user_message(body) is None


def test_extract_last_user_message_invalid_json():
    body = b"not json"
    assert _extract_last_user_message(body) is None


def test_extract_last_user_message_multimodal():
    """Multimodal content (list) extracts the text part."""
    body = b'{"messages":[{"role":"user","content":[{"type":"text","text":"Describe this"},{"type":"image_url","image_url":{}}]}]}'
    assert _extract_last_user_message(body) == "Describe this"
```

**Step 2: Run the new tests to verify they fail**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_openclaw_proxy.py::test_extract_last_user_message_simple -v`
Expected: FAIL — `cannot import name '_extract_last_user_message'`

**Step 3: Add `_extract_last_user_message` helper to `app/routers/openclaw_proxy.py`**

Add after the `_STRIP_MARKERS` section, before the route:

```python
def _extract_last_user_message(body: bytes) -> str | None:
    """Extract the last user message text from an OpenAI-format request body."""
    try:
        data = json.loads(body)
    except (json.JSONDecodeError, ValueError):
        return None

    messages = data.get("messages", [])
    for msg in reversed(messages):
        if msg.get("role") != "user":
            continue
        content = msg.get("content")
        if isinstance(content, str):
            return content
        if isinstance(content, list):
            for part in content:
                if isinstance(part, dict) and part.get("type") == "text":
                    return part.get("text")
        return None
    return None
```

Add `import json` to the top of the file.

**Step 4: Run the helper tests to verify they pass**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/test_openclaw_proxy.py -k "extract" -v`
Expected: All 5 extract tests PASS

**Step 5: Write the proxy filler injection logic**

Now modify the `proxy_chat_completions` route handler. Replace the entire function with:

```python
@router.api_route("/v1/chat/completions", methods=["POST"])
async def proxy_chat_completions(request: Request):
    """Proxy POST /v1/chat/completions to the local OpenClaw gateway.

    Injects filler phrases via Deepgram InjectAgentMessage when the
    response takes longer than FILLER_THRESHOLD_MS.
    """
    body = await request.body()
    headers = {
        k: v
        for k, v in request.headers.items()
        if k.lower() not in ("host", "content-length", "transfer-encoding")
    }

    # --- Filler setup ---
    settings = get_settings()
    session_key = request.headers.get("x-openclaw-session-key")
    dg_ws = get_ws(session_key) if session_key else None
    threshold_ms = settings.FILLER_THRESHOLD_MS

    filler_task: asyncio.Task | None = None

    if dg_ws and threshold_ms > 0:
        user_message = _extract_last_user_message(body)
        dynamic_phrase_holder: list[str | None] = [None]

        # Kick off dynamic generation in parallel
        if settings.FILLER_DYNAMIC and settings.ANTHROPIC_API_KEY and user_message:
            async def _gen():
                dynamic_phrase_holder[0] = await generate_filler_phrase(
                    user_message, settings.ANTHROPIC_API_KEY
                )

            asyncio.create_task(_gen())

        # Schedule filler injection after threshold
        async def _inject_filler():
            await asyncio.sleep(threshold_ms / 1000)
            phrase = dynamic_phrase_holder[0]
            if not phrase:
                phrases = settings.filler_phrases_list
                phrase = random.choice(phrases) if phrases else None
            if not phrase:
                return
            try:
                logger.info("Injecting filler: %s", phrase)
                await dg_ws.send(json.dumps({"type": "InjectAgentMessage", "message": phrase}))
            except Exception:
                logger.debug("Failed to inject filler", exc_info=True)

        filler_task = asyncio.create_task(_inject_filler())

    # --- Forward to OpenClaw ---
    client = httpx.AsyncClient(timeout=httpx.Timeout(connect=10, read=120, write=10, pool=10))
    req = client.build_request(
        "POST",
        f"{OPENCLAW_BASE}/v1/chat/completions",
        content=body,
        headers=headers,
    )
    resp = await client.send(req, stream=True)

    async def stream_body():
        try:
            first_chunk = True
            async for chunk in _filtered_stream(resp.aiter_bytes()):
                if first_chunk and filler_task and not filler_task.done():
                    filler_task.cancel()
                    first_chunk = False
                yield chunk
        finally:
            if filler_task and not filler_task.done():
                filler_task.cancel()
            await resp.aclose()
            await client.aclose()

    return StreamingResponse(
        content=stream_body(),
        status_code=resp.status_code,
        headers=dict(resp.headers),
    )
```

Add these imports to the top of the file:

```python
import asyncio
import json
import random

from app.config import get_settings
from app.services.filler import generate_filler_phrase
from app.services.session_registry import get_ws
```

**Step 6: Run all tests to verify everything passes**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/ -v`
Expected: All tests PASS. The existing proxy test still passes because it doesn't set up a session registry entry, so `dg_ws` is `None` and filler logic is skipped.

**Step 7: Write filler-specific proxy tests**

Add these tests to `tests/test_openclaw_proxy.py`:

```python
import asyncio
import json

from app.services import session_registry


@pytest.mark.asyncio
async def test_proxy_injects_filler_on_slow_response(monkeypatch):
    """When response is slow and a session is registered, filler is injected."""
    from httpx import AsyncClient
    from app.config import Settings

    # Register a mock Deepgram WS
    mock_dg_ws = AsyncMock()
    session_registry.register("agent:main:slow-call", mock_dg_ws)

    # Configure settings with low threshold for test speed
    test_settings = Settings(
        DEEPGRAM_API_KEY="test-key",
        OPENCLAW_GATEWAY_TOKEN="gw-token",
        FILLER_THRESHOLD_MS=50,  # 50ms for fast test
        FILLER_PHRASES="One moment...,Working on it.",
        FILLER_DYNAMIC=False,  # Disable Haiku for this test
        _env_file=None,
    )
    monkeypatch.setattr("app.routers.openclaw_proxy.get_settings", lambda: test_settings)

    # Simulate a slow OpenClaw response (200ms delay before response)
    async def slow_send(request, *, stream=False):
        await asyncio.sleep(0.2)  # 200ms > 50ms threshold
        resp = MagicMock()
        resp.status_code = 200
        resp.headers = {"content-type": "text/event-stream"}

        async def aiter_bytes():
            yield b'data: {"choices":[{"delta":{"content":"Hello"}}]}\n\n'
            yield b"data: [DONE]\n\n"

        resp.aiter_bytes = aiter_bytes
        resp.aclose = AsyncMock()
        return resp

    mock_client = AsyncMock()
    mock_client.build_request = MagicMock(return_value=MagicMock())
    mock_client.send = slow_send
    mock_client.aclose = AsyncMock()
    monkeypatch.setattr("app.routers.openclaw_proxy.httpx.AsyncClient", lambda **kw: mock_client)

    from httpx import ASGITransport
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as test_client:
        resp = await test_client.post(
            "/v1/chat/completions",
            json={"model": "test", "messages": [{"role": "user", "content": "hello"}]},
            headers={"x-openclaw-session-key": "agent:main:slow-call"},
        )

    assert resp.status_code == 200

    # Filler should have been injected
    mock_dg_ws.send.assert_called_once()
    injected = json.loads(mock_dg_ws.send.call_args[0][0])
    assert injected["type"] == "InjectAgentMessage"
    assert injected["message"] in ["One moment...", "Working on it."]

    # Cleanup
    session_registry.unregister("agent:main:slow-call")


@pytest.mark.asyncio
async def test_proxy_skips_filler_on_fast_response(monkeypatch):
    """When response is fast, no filler is injected."""
    from httpx import AsyncClient
    from app.config import Settings

    mock_dg_ws = AsyncMock()
    session_registry.register("agent:main:fast-call", mock_dg_ws)

    test_settings = Settings(
        DEEPGRAM_API_KEY="test-key",
        OPENCLAW_GATEWAY_TOKEN="gw-token",
        FILLER_THRESHOLD_MS=500,  # 500ms threshold
        FILLER_PHRASES="One moment...",
        FILLER_DYNAMIC=False,
        _env_file=None,
    )
    monkeypatch.setattr("app.routers.openclaw_proxy.get_settings", lambda: test_settings)

    # Fast response (no delay)
    async def fast_send(request, *, stream=False):
        resp = MagicMock()
        resp.status_code = 200
        resp.headers = {"content-type": "text/event-stream"}

        async def aiter_bytes():
            yield b'data: {"choices":[{"delta":{"content":"Quick response"}}]}\n\n'
            yield b"data: [DONE]\n\n"

        resp.aiter_bytes = aiter_bytes
        resp.aclose = AsyncMock()
        return resp

    mock_client = AsyncMock()
    mock_client.build_request = MagicMock(return_value=MagicMock())
    mock_client.send = fast_send
    mock_client.aclose = AsyncMock()
    monkeypatch.setattr("app.routers.openclaw_proxy.httpx.AsyncClient", lambda **kw: mock_client)

    from httpx import ASGITransport
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as test_client:
        resp = await test_client.post(
            "/v1/chat/completions",
            json={"model": "test", "messages": [{"role": "user", "content": "hello"}]},
            headers={"x-openclaw-session-key": "agent:main:fast-call"},
        )

    assert resp.status_code == 200

    # No filler should have been injected
    mock_dg_ws.send.assert_not_called()

    # Cleanup
    session_registry.unregister("agent:main:fast-call")


@pytest.mark.asyncio
async def test_proxy_skips_filler_when_no_session(monkeypatch):
    """When no session is registered for the key, no filler logic runs."""
    from httpx import AsyncClient
    from app.config import Settings

    test_settings = Settings(
        DEEPGRAM_API_KEY="test-key",
        OPENCLAW_GATEWAY_TOKEN="gw-token",
        FILLER_THRESHOLD_MS=50,
        FILLER_PHRASES="One moment...",
        FILLER_DYNAMIC=False,
        _env_file=None,
    )
    monkeypatch.setattr("app.routers.openclaw_proxy.get_settings", lambda: test_settings)

    async def fast_send(request, *, stream=False):
        resp = MagicMock()
        resp.status_code = 200
        resp.headers = {"content-type": "application/json"}

        async def aiter_bytes():
            yield b'{"choices":[{"message":{"content":"hi"}}]}'

        resp.aiter_bytes = aiter_bytes
        resp.aclose = AsyncMock()
        return resp

    mock_client = AsyncMock()
    mock_client.build_request = MagicMock(return_value=MagicMock())
    mock_client.send = fast_send
    mock_client.aclose = AsyncMock()
    monkeypatch.setattr("app.routers.openclaw_proxy.httpx.AsyncClient", lambda **kw: mock_client)

    from httpx import ASGITransport
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as test_client:
        resp = await test_client.post(
            "/v1/chat/completions",
            json={"model": "test", "messages": [{"role": "user", "content": "hello"}]},
            headers={"x-openclaw-session-key": "agent:main:no-session"},
        )

    # Should succeed without any filler injection (no crash, no side effects)
    assert resp.status_code == 200


@pytest.mark.asyncio
async def test_proxy_skips_filler_when_threshold_zero(monkeypatch):
    """Filler disabled when threshold is 0."""
    from httpx import AsyncClient
    from app.config import Settings

    mock_dg_ws = AsyncMock()
    session_registry.register("agent:main:disabled", mock_dg_ws)

    test_settings = Settings(
        DEEPGRAM_API_KEY="test-key",
        OPENCLAW_GATEWAY_TOKEN="gw-token",
        FILLER_THRESHOLD_MS=0,  # Disabled
        FILLER_PHRASES="One moment...",
        FILLER_DYNAMIC=False,
        _env_file=None,
    )
    monkeypatch.setattr("app.routers.openclaw_proxy.get_settings", lambda: test_settings)

    async def slow_send(request, *, stream=False):
        await asyncio.sleep(0.1)
        resp = MagicMock()
        resp.status_code = 200
        resp.headers = {"content-type": "text/event-stream"}

        async def aiter_bytes():
            yield b'data: {"choices":[{"delta":{"content":"Slow"}}]}\n\n'

        resp.aiter_bytes = aiter_bytes
        resp.aclose = AsyncMock()
        return resp

    mock_client = AsyncMock()
    mock_client.build_request = MagicMock(return_value=MagicMock())
    mock_client.send = slow_send
    mock_client.aclose = AsyncMock()
    monkeypatch.setattr("app.routers.openclaw_proxy.httpx.AsyncClient", lambda **kw: mock_client)

    from httpx import ASGITransport
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as test_client:
        resp = await test_client.post(
            "/v1/chat/completions",
            json={"model": "test", "messages": [{"role": "user", "content": "hello"}]},
            headers={"x-openclaw-session-key": "agent:main:disabled"},
        )

    assert resp.status_code == 200
    mock_dg_ws.send.assert_not_called()

    session_registry.unregister("agent:main:disabled")
```

**Step 8: Run all tests**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/ -v`
Expected: All tests PASS

**Step 9: Commit**

```bash
git add Deepgram/deepgram_handler/app/routers/openclaw_proxy.py Deepgram/deepgram_handler/tests/test_openclaw_proxy.py
git commit -m "feat(sidecar): inject filler phrases on slow think endpoint responses"
```

---

### Task 6: Run Full Test Suite and Verify

**Step 1: Run the complete test suite**

Run: `cd Deepgram/deepgram_handler && uv run pytest tests/ -v`
Expected: All tests PASS

**Step 2: Run ruff lint**

Run: `cd Deepgram/deepgram_handler && uv run ruff check app/ tests/`
Expected: No errors

**Step 3: Run ruff format check**

Run: `cd Deepgram/deepgram_handler && uv run ruff format --check app/ tests/`
Expected: No formatting issues (or fix with `uv run ruff format app/ tests/`)

**Step 4: Final commit (if any lint fixes)**

```bash
git add -u Deepgram/deepgram_handler/
git commit -m "style(sidecar): fix lint and formatting for filler phrases"
```
